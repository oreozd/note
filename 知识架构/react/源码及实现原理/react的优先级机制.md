对于优先级机制我浅显的理解是高优先级的任务可以打断低优先级的任务先去执行，在这个过程中就会有高优先级任务一直执行，会导致低优先级任务饿死的情况，所以在高低优先级之外还有一层时间控制逻辑，到达时间的任务会提升为同步任务去立刻执行。

真正去执行任务的是scheduler模块，它是直接与浏览器引擎发生交互的。

react中会产生更新任务，有自己的优先级。这个优先级决定了哪些任务可以在本次被调度到，也就是被放到待调度队列中

但是被放入调度队列中的任务，是否可以在本次时间片中被执行，还取决于scheduler，取决于这个调度任务队列中的任务是否满足执行条件，同步的会立马被执行，异步的会按照优先级去执行，scheduler的调度逻辑主要通过时间进行控制。
但是它是如何与scheduler发生作用的呢？

只有render阶段会有这些困扰，commit阶段是一个不被打扰的完整流程。

把平时几毫秒里运行的事情拆解开来就是很困难，会比较抽象，在现实中找不到可以对应的事务，所以需要去硬理解。或者说临时去建立理解的模型，这是一项很困难的活动，首先人是害怕抽象的，为什么对于抽象有本能的恐惧和排斥呢。

如果是我遇到这样的问题，我的解决思路是什么呢？

事件优先级
任务优先级
更新优先级

只有在cocurrent模式下才会有这种优先级调度机制

每一次的更新都会产生一个新的fiber树，

感觉每个部分都是知道一点点，但是不连贯。没有办法连起来的感觉。


update的优先级是通过计算得来的
root.pendingLanes表示react需要在本次处理的更新
产生更新任务，react开始构建WIP树，会找到最紧急的lanes作为renderLanes,这个renderLanes会在整个创建WIP树的过程中持续存在，处理更新的fiber节点上的update链表的时，会找出 lane 在 renderLanes 范围中的update去执行。

会先去产生优先级，注册优先级，然后才是真正的处理更新。
处理更新的过程无非就是一些计算，这些操作需要在浏览器主线程中去执行，所以要去遵循scheculer的调度。

执行完高优先级的任务，低优先级的任务也是需要去执行的，所以接下去的流程是什么流程。

没有一个宏观上的认识，然后就直接去搞细节真的很崩溃。

setState的执行总会有时机，不管是通过用户通过触发事件去触发，通过一些宏微任务的触发。

setState执行的结果就是产生一个update对象，并将这个对象放进fiber节点的updateQueue中，每一个更新都会经历这样的阶段，但是更新是否会马上去应用，还是需要依赖于优先级机制。

每个update对象都会有一个表示优先级的字段标识 lane, 这个字段的值是通过计算的，因为在这个阶段，还并不具有优先级的概念，那么这个值是如何进行计算的

和合成事件有关，在事件挂载的时候，已经通过调用 runWithPriority() 将事件优先级转化为scheduler中的优先级，所以计算update的lane就会去拿 shceduler中的优先级？？是这样的吗。

更新被翻译为react系统语言之后，就是需要去执行了，也就是要进行reconcile操作。

这说的是一个组件的更新，那整个应用包含层层的组件，所以我此处的root节点只是单个组件的意思。

生成updateQueue之后就需要去执行更新了，在执行之前需要进行一系列的准备工作，在准备阶段主要进行的一些工作
判断是否会存在一些无限循环的update
从当前节点向上查找，收集fiber.lanes,收集到父级节点的 childLanes，用于标识该组件是否产生了更新
在root上标记更新，将update中的lane放在root.pendingLanes中，每次渲染的基准值是从 pendingLanes 中取出最紧急的一部分作为 renderLanes。

一个update会使react产生一棵新的fiber树

react调度不涉及任务的执行，只是为shceduler调度提供了一个跟高级的控制标准
sheduler调度是真的控制任务的执行，更直观的来说是对任务执行时机的一种控制。

任务优先级，是指renderLanes对应的lanePriority
有三类任务优先级
同步优先级
同步批量
concurren模式

任务优先级决定任务在react中被如何调度，任务优先级转化为任务调度优先级，决定shduler在什么时间处理这个任务。
scheduler调度只是根据浏览器的工作流程去安排任务的执行，这个任务中执行的操作具体有什么。

本质上还是通过修改state的值，来进行视图的更新

浏览器的视图每一帧都在刷新，这个是一直在运行的底层机制，所以要让我们的运行逻辑去搭载这样的底层运行逻辑，就可以实现自动更新的类似效果。